# ============================================================================
# CI/CD STAGING - AWS ECS FARGATE 
# ============================================================================
# Workflow pour la branche 'develop' 
# DÃ©ploie automatiquement sur AWS ECS Fargate (environnement de staging)

name: ğŸš€ Deploy Staging (AWS)

on:
  push:
    branches: [develop]
    paths:
      - 'app/**'
      - 'terraform/environments/aws-complete/**'
      - 'terraform/modules/**'
      - '.github/workflows/staging-aws.yml'

  # DÃ©ploiement manuel optionnel
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without changes'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-west-1
  ECR_REPOSITORY: portfolio-prod-app
  ECS_SERVICE: portfolio-prod-service
  ECS_CLUSTER: portfolio-prod-cluster

jobs:
  # ============================================================================
  # BUILD & PUSH TO ECR
  # ============================================================================
  build-and-push:
    name: ğŸ”¨ Build & Push to ECR
    runs-on: ubuntu-latest
    outputs:
      image-uri: ${{ steps.build.outputs.image }}
      
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš™ï¸ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ” Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: ğŸ—ï¸ Build and push Docker image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          cd app
          
          # Build image
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          
          # Push images
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          # Output image URI
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  # ============================================================================
  # DEPLOY TO AWS ECS FARGATE
  # ============================================================================
  deploy-aws:
    name: ğŸš€ Deploy to AWS ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: âš™ï¸ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: ğŸ” Setup GCP credentials (for provider initialization only)
        run: |
          # Create credentials file for GCP provider initialization
          # Note: GCP resources won't be created, this is only for Terraform init
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' > /tmp/gcp-key.json
          echo "GOOGLE_APPLICATION_CREDENTIALS=/tmp/gcp-key.json" >> $GITHUB_ENV

      - name: ğŸ—ï¸ Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ~1.6

      - name: ï¿½ Import existing AWS resources
        run: |
          cd terraform/environments/aws-complete
          
          # Initialize Terraform with backend first
          terraform init
          
          # Run smart import script
          chmod +x ../../../scripts/import-existing-aws.sh
          ../../../scripts/import-existing-aws.sh

      - name: ğŸš€ Deploy infrastructure
        env:
          TF_VAR_container_image: ${{ needs.build-and-push.outputs.image-uri }}
          TF_VAR_gcp_credentials: /tmp/gcp-key.json
          TF_VAR_desired_count: 1
        run: |
          cd terraform/environments/aws-complete
          
          # Plan deployment (should show minimal or no changes)
          terraform plan -out=tfplan
          
          # Apply deployment
          terraform apply -auto-approve tfplan
          
          # Get outputs
          echo "ğŸŒ Load Balancer URL: $(terraform output -raw load_balancer_url)"

      - name: ï¿½ Force ECS service deployment
        run: |
          cd terraform/environments/aws-complete
          
          # Get cluster and service names from Terraform outputs
          CLUSTER_NAME=$(terraform output -raw ecs_cluster_name)
          SERVICE_NAME=$(terraform output -raw ecs_service_name)
          
          echo "ğŸ”„ Forcing ECS service to pull new image..."
          aws ecs update-service \
            --cluster $CLUSTER_NAME \
            --service $SERVICE_NAME \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… New deployment triggered!"

      - name: ï¿½ğŸ” Health check
        run: |
          cd terraform/environments/aws-complete
          
          # Get ALB URL
          ALB_URL=$(terraform output -raw load_balancer_url)
          
          # Wait for deployment to stabilize
          echo "â³ Waiting for new tasks to start (2 minutes)..."
          sleep 120
          
          # Health check with retries
          echo "ğŸ” Running health checks..."
          for i in {1..10}; do
            echo "ğŸ” Health check attempt $i/10"
            if curl -f -s "$ALB_URL/health" > /dev/null; then
              echo "âœ… Health check passed!"
              echo "ğŸ“„ Response headers:"
              curl -I "$ALB_URL"
              exit 0
            fi
            echo "â³ Waiting 15s before retry..."
            sleep 15
          done
          
          echo "âŒ Health check failed after 10 attempts"
          exit 1

  # ============================================================================
  # NOTIFICATION
  # ============================================================================ 
  notify:
    name: ğŸ“¢ Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-aws]
    if: always()
    
    steps:
      - name: ğŸ“¢ Deployment status
        run: |
          if [ "${{ needs.deploy-aws.result }}" == "success" ]; then
            echo "âœ… AWS Staging deployment successful!"
            echo "ğŸŒ Environment: Staging (AWS ECS Fargate)"
            echo "ğŸ“¦ Image: ${{ needs.build-and-push.outputs.image-uri }}"
          else
            echo "âŒ AWS Staging deployment failed!"
            exit 1
          fi